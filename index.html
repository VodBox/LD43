<html>
	<head>
		<link rel="stylesheet" href="cssReset.css">
		<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
		<script src="pixi.js"></script>
		<script src="howler.js"></script>
		<script src="utils.js"></script>
		<script src="screens/menu.js"></script>
		<script src="screens/level1.js"></script>
		<script src="screens/level2.js"></script>
		<script src="screens/level3.js"></script>
		<script src="screens/level4.js"></script>
		<script src="screens/level5.js"></script>
		<script src="screens/level6.js"></script>
		<script src="screens/level7.js"></script>
		<script src="screens/level8.js"></script>
		<style>

		</style>
	</head>
	<body>
		<script>
			w = 1280;
			h = 720;

			var logo;
			var loading;
			var bar;
			var frontBar;
			var block;

			var game = new PIXI.Renderer({
				width: w,
				height: h,
				antialias: true
			});
			document.body.appendChild(game.view);

			var stage = new PIXI.Container();
			stage.activeScreen = null;
			stage.loadScreen = null;

			function preload() {
				block = new PIXI.Graphics();
				block.drawRect(0,0,w,h);
				block.baseAlpha = 1;

				logo = new PIXI.Sprite.from('./logo.png');
				console.log(logo);

				let logoSize = Math.min(w/5, h/2);
				logo.anchor = {
					x: 0.5, y: 0.5
				};
				logo.width = logoSize;
				logo.height = logoSize;
				logo.x = w/2;
				logo.y = h/2;

				loading = new PIXI.Text('Loading...',{fontFamily : 'Roboto', fontSize: 32, fill : 0xffffff, align : 'center'});
				loading.anchor = {
					x: 0.5, y: 0
				};
				loading.x = w/2;
				loading.y = h/2 + logoSize/2;

				bar = new PIXI.Graphics();
				bar.anchor = {x: 0.5, y: 0.5};
				bar.x = w/2;
				bar.y = h/2 + logoSize/2 + 50;
				bar.beginFill(0x333333, 1);
				bar.drawRect(-logoSize/4, 0, logoSize/2, 20);
				bar.endFill();

				frontBar = new PIXI.Graphics();
				frontBar.x = w/2 - logoSize/4;
				frontBar.y = h/2 + logoSize/2 + 50;
				frontBar.beginFill(0xFF9999, 1);
				frontBar.drawRect(0, 0, 1, 20);
				frontBar.endFill()

				stage.addChild(logo);
				stage.addChild(block);
				stage.addChild(loading);
				stage.addChild(bar);
				stage.addChild(frontBar);
			}

			var loaded = false;
			function load() {
				levels['menu'] = menu.load();
				levels['level1'] = level1.load();
				levels['level2'] = level2.load();
				levels['level3'] = level3.load();
				levels['level4'] = level4.load();
				levels['level5'] = level5.load();
				levels['level6'] = level6.load();
				levels['level7'] = level7.load();
				//levels['level8'] = level8.load();

				for(let i = 0; i < 10; ++i) {
					characters[i] = createCharacter("char/" + i + ".json");
					characters[i].id = i;
				}
			}

			var levels = {};
			var characters = [];

			var activeKeys = {};
			document.onkeydown = function(e) {
				activeKeys[e.keyCode] = true;
				if(e.keyCode == 107) {
					++parNum;
				}
				if(e.keyCode == 109) {
					--parNum;
				}
			};
			document.onkeyup = function(e) {
				delete activeKeys[e.keyCode];
			};

			var parNum = 0;

			function gameLoop() {
				if(stage.activeScreen == null) {
					stage.addChild(levels['menu'].level);
					stage.activeScreen = levels['menu'];
				}
				if(stage.loadScreen != null) {
					stage.removeChild(stage.activeScreen.level);
					stage.addChild(stage.loadScreen.level);
					stage.activeScreen = stage.loadScreen;
					stage.loadScreen = null;
					for(let char in characters) {
						if(stage.children.includes(characters[char].char)) {
							stage.removeChild(characters[char].char);
						}
						if(characters[char].screen == stage.activeScreen.name) {
							stage.addChild(characters[char].char);
						}
					}
				}

				if(stage.activeScreen.name != "menu") {
					if(characters[parNum].screen != stage.activeScreen.name) {
						stage.loadScreen = levels[characters[parNum].screen];
					} else {
						if(stage.activeScreen.tick) {
							stage.activeScreen.tick();
							for(let i = 0, l = characters.length; i < l; ++i) {
								let curChar = characters[i].char;
								let onGround = checkPoint(
									stage.activeScreen, curChar.x,
									curChar.y + curChar.height + 1, characters[i])
									|| checkPoint(
										stage.activeScreen, curChar.x + curChar.width,
										curChar.y + curChar.height + 1, characters[i]);
								if(i == parNum) {
									if(activeKeys[87] && onGround) {
										curChar.dy = -16;
									}
									if(activeKeys[83]) {
										curChar.y += 20;
									}
									if((activeKeys[65] && activeKeys[68]) || (!activeKeys[65] && !activeKeys[68])) {
										curChar.dx += (curChar.dx == 0 ? 0 : (curChar.dx > 0 ? -2 : 2));
									} else if(activeKeys[65]) {
										curChar.dx = Math.max(curChar.dx - 2, -12);
									} else if(activeKeys[68]) {
										curChar.dx = Math.min(curChar.dx + 2, 12);
									}
								} else {
									curChar.dx = 0;
								}
								if(characters[i].screen == stage.activeScreen.name) {
									checkMove(stage.activeScreen, characters[i], onGround);
								}
							}
						}
					}
				}
			}

			function moveAwayFromDoor(char) {
				for(let i = 0, l = characters.length; i < l; ++i) {
					let oChar = characters[i];
					if(oChar != char && oChar.screen == char.screen) {
						if(Math.abs(oChar.char.y - char.char.y) < 2) {
							if(char.char.x < w/2) {
								if((oChar.char.x < char.char.x + char.char.width
								&& oChar.char.x > char.char.x)
								|| (oChar.char.x + oChar.char.width < char.char.x + char.char.width
								&& oChar.char.x + oChar.char.width > char.char.x)) {
									oChar.char.x += h*1.5/10;
									moveAwayFromDoor(oChar);
								}
							}
						}
					}
				}
			}

			function checkMove(cur, char, onGround) {
		        for(let i = 0, l = cur.adj.length; i < l; ++i) {
		            let adj = cur.adj[i];
		            if(char.char.x > adj.box[0]
		                && char.char.x < adj.box[0] + adj.box[2]
		                && char.char.y > adj.box[1]
		                && char.char.y < adj.box[1] + adj.box[3]) {
		                stage.loadScreen = levels[adj.level.name];
		                char.screen = adj.level.name;
		                char.char.x += adj.offset[0];
		                char.char.y += adj.offset[1];
						moveAwayFromDoor(char);
		            }
		        }
				if(char.screen == cur.name) {
					char.char.dy += 0.5;
					if(onGround) {
						char.char.dy = Math.min(char.char.dy, 0);
					}
					if(char.char.dy != 0) {
						charPhysicsY(cur, char);
					}
					if(char.char.dx != 0) {
						charPhysicsX(cur, char);
					}
				}
		    }

			function charPhysicsY(cur, char) {
				var yPosChecks = [
					{x: char.char.x, y: char.char.y - 1},
					{x: char.char.x + char.char.width, y: char.char.y - 1},
					{x: char.char.x + char.char.width, y: char.char.y + char.char.height + 1},
					{x: char.char.x, y: char.char.y + char.char.height + 1},
				];
				let dy = char.char.dy;
				let yDir = (char.char.dy < 0 ? -1 : 1);
				for(let pos in yPosChecks) {
					let p = yPosChecks[pos];
					for(let i = 0, l = cur.collisionSurfaces.length; i < l; ++i) {
						let surf = cur.collisionSurfaces[i];
						while(surf.containsPoint({x:p.x,y:p.y+dy})) {
							dy -= 0.5 * yDir;
						}
					}
					for(let i = 0, l = characters.length; i < l; ++i) {
						let oChar = characters[i];
						if(oChar != char && oChar.screen == char.screen) {
							while(oChar.char.containsPoint({x:p.x,y:p.y+dy})) {
								dy -= 0.5;
							}
						}
					}
				}
				char.char.y += dy + 1;
				char.char.y = Math.floor(char.char.y) + 1;
				char.char.dy = dy;
			}

			function charPhysicsX(cur, char) {
				var xPosChecks = [
					{x: char.char.x, y: char.char.y + 3},
					{x: char.char.x + char.char.width, y: char.char.y + 3},
					{x: char.char.x + char.char.width, y: char.char.y + char.char.height-3},
					{x: char.char.x, y: char.char.y + char.char.height-3},
				];
				let dx = char.char.dx;
				let xDir = (char.char.dx > 0 ? 1 : -1);
				for(let pos in xPosChecks) {
					let p = xPosChecks[pos];
					for(let i = 0, l = cur.collisionSurfaces.length; i < l; ++i) {
						let surf = cur.collisionSurfaces[i];
						while(surf.containsPoint({x:p.x+dx,y:p.y})) {
							dx -= xDir * 0.25;
						}
					}
					for(let i = 0, l = characters.length; i < l; ++i) {
						let oChar = characters[i];
						if(oChar != char && oChar.screen == char.screen) {
							while(oChar.char.containsPoint({x:p.x+dx,y:p.y})) {
								dx -= xDir * 0.25;
							}
						}
					}
				}
				char.char.x += dx;
			}

			function checkPoint(cur, x, y, char) {
				let con = false;
				for(let i = 0, l = cur.collisionSurfaces.length; i < l; ++i) {
					let surf = cur.collisionSurfaces[i];
					if(!surf.ceiling && surf.containsPoint({x:x,y:y})) {
						con = true;
						break;
					}
				}
				if(!con) {
					for(let i = 0, l = characters.length; i < l; ++i) {
						let oChar = characters[i];
						if(oChar != char && oChar.screen == char.screen) {
							if(oChar.char.containsPoint({x:x,y:y})) {
								con = true;
								break;
							}
						}
					}
				}
				return con;
			}

			function render() {

			}

			var loadWidth = 0;
			var gr = false;

			var prevTime = Date.now();
			function drawLoop(t) {
				let newTime = Date.now();
				let dt = newTime-prevTime;
				prevTime = newTime;

				if(loaded && logo) {
					if(loading) {
						loading.destroy();
						loading = undefined;
						bar.destroy();
						bar = undefined;
						frontBar.destroy();
						frontBar = undefined;
					}
					block.alpha += dt/2000;
					if(block.alpha > 1) {
						logo.destroy();
						logo = undefined;
						block.destroy();
						block = undefined;
					}
				} else if(logo && logo._texture.baseTexture.valid) {
					block.baseAlpha = Math.max(block.baseAlpha - dt/1000, 0);
					block.alpha = Math.min(block.baseAlpha + (Math.sin(t/750)+1)/2 * 0.3, 1);

					let loadNum = 0;
					let loadLen = 0;
					for(let level in levels) {
						++loadLen;
						loadNum += (levels[level].loaded ? 1 : 0);
					}
					for(let char in characters) {
						++loadLen;
						loadNum += (characters[char].loaded ? 1 : 0);
					}

					loadWidth = bar.width * loadNum / loadLen;
					if(loadNum == loadLen) {
						loaded = true;
						block.alpha = 0;
					}

					frontBar.width = Math.min(loadWidth, bar.width);
				} else if(loaded && !gr) {
					window.setInterval(gameLoop, 1000/60);
					gr = true;
				}

				render();
				game.render(stage);

				window.requestAnimationFrame(drawLoop);
			}
			window.requestAnimationFrame(drawLoop);

			preload();
			load();
		</script>
	</body>
</html>
